* 16 -> 2
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int hextobin(char *hex){
    int i,h;
    int len = strlen(hex)-1;
    int buf[4];

    while(len--)
    {
        printf("%c: ", *hex);
        if (isupper(*hex)) {
            h = *hex++ - 'A' + 10;
        } else if(islower(*hex)) {
            h = *hex++ - 'a' + 10;
        } else {
            h = *hex++ - 48;
        }

        for(i=3; i>=0; i--) {
            buf[i] = h % 2;
            h = h / 2;
        }

        for(i=0; i<4; i++) {
            printf("%d", buf[i]);
        }

        printf("\n");
    }

    return 0;
}

int main() {
    hextobin("c0131e30");
    return 0;
}


* result
$ ./hextobin.exe
c: 1100
0: 0000
1: 0001
3: 0011
1: 0001
e: 1110
3: 0011
==================================================================================

1.strcmp함수로 문자열을 비교했을 때 반환값이 올바른 것을 모두 고르세요(Visual Studio 기준).

a.strcmp("hello", "hello"); → 1
b.strcmp("hello", "world"); → 1
c.strcmp("hello", "world"); → -1
d.strcmp("world", "world"); → 0
e.strcmp("ccc", "ddd"); → 0
f.strcmp("ccc", "ddd"); → -1
하나 혹은 하나 이상을 선택하세요. 

 
2.. strcpy 함수를 사용하여 "Hello" 문자열을 char 배열에 복사할 때 배열의 최소 크기는 얼마가 되어야 할까요?
a. 5 
b. 6 
c. 8 
d. 10 
e. 20 
하나를 선택하세요.

3. strcat 함수를 사용하여 "Hello" 문자열과 "world" 문자열을 붙였을 때 최종 문자열이 차지하는 공간은 몇 바이트일까요? 
   (숫자만 입력) 각 문자열은 char 배열입니다.

4.strcpy 함수가 선언된 헤더 파일은?
a. stdio.h 
b. stdlib.h 
c. string.h 
d. limits.h 
e. strings.h 
하나를 선택하세요. 

5. 문자 배열 s1에 "Hello, world!" 문자열을 생성하여 저장하는 코드로 올바른 것을 고르세요.
a.sprintf("Hello, %s", s1, "world!");
b.sprintf("Hello, %s", "world!");
c.sprintf("Hello, %s", s1);
d.sprintf(s1, "Hello, %s", "world!");
e.sprintf("world!", "Hello, %s", s1);
하나를 선택하세요.

6.문자 배열 s1이 "a 10" 형태가 되도록 코드를 완성하세요.
sprintf(s1,  빈칸, 'a', 10);

7.다음 중 문자열 안에서 문자로 검색하는 함수를 모두 고르세요.
a. strcmp 
b. strstr 
c. strchr 
d. strcpy 
e. strrchr 
f. strcat 

8.문자 배열 s1에서 "Dia"으로 시작하는 문자열을 검색한 뒤 메모리 주소를 ptr에 저장하려고 합니다. 올바른 코드를 고르세요.
a.char s1 = strstr(ptr, "Dia");
b.char *ptr = strstr(s1, "Dia");
c.strstr *ptr = char(s1, "Dia");
d.char *s1 = strstr("Dia", ptr);
e.char ptr = strstr("Dia", s1);
하나를 선택하세요.

9.다음 중 문자열을 자르는 함수는?
a. strcmp 
b. strstr 
c. strchr 
d. strtok 
e. strrchr 


10.strtok 함수의 설명으로 잘못된 것을 모두 고르세요.
a. 기준 문자는 하나만 지정할 수 있음 
b. 문자열을 자를 때 기준 문자 부분을 NULL로 채움 
c. 문자열을 복제한 뒤 포인터를 반환함 
d. 자르는 문자열의 내용을 바꿈 
e. strtok(NULL, " ")처럼 NULL을 넣어주면 이전 strtok 함수에서 처리했던 문자열에서 잘린 문자열만큼 문자로 이동한 뒤 다음 문자열을 자름 
f. 잘린 문자열의 포인터만 반환함 
   
1. c,d,f 
2. b 
3. 11 
4. C 
5. d 
6. "%c %d" 
7. c,e 
8. b 
9. d 
10. a, c 
==================================================================================
typedef 함수포인터 사용

지난번에 이야기한 struct의 typedef을 사용한 바와 같이typedef은 데이터 타입에 대해서 따로 별명을 붙여서 주어 간편하게 쓰는데 목적이 있다고 했다.
그럼 함수포인터에 대해서 typedef을 쓰는이유는? 당연히 간편하게 쓸려고 그런거다.

우선 함수포인터의 쓰는 방법 부터 보자.
int test(int num){
	printf("input num is %d.\n", num);
}

int main()
{
	int (*testptr)(int);
	testptr = test;
	testptr(100);
}

위의 코드에서와 같이 호출하고자 하는 함수 이름 대신에 별표(*) 포인터변수를 적어주면된다.

    ****>> 리턴타입 + (* 함수포인터 변수) ( 함수 인자 타입, .... )
    
그럼 왜 typedef 함수 포인터를 선언하는가?
예제에서와 같이 int (*testptr)(int); 식으로 적어서 함수포인터 변수를 선언하면 되는데 매번 이런식으로 적으면 코드가 길어지기도 하지만 
뭔가 눈에 쏙쏙들어오지 않는다.보통 변수타입 + 변수명 으로 선언을 하기 때문에 그렇다. 
그래서 아래와 같이
typedef int (*TestFuncPtr)(int);

이런 식으로 선언을 해놓고 아래와 같이 쓰면 보기에도 좋고 간편하니 보통 이렇게 쓴다.
TestFuncPtr testptr;

정리
함수포인터를 typedef 선언해서 쓰는 이유는 보기 쉽고 간편해서이다.

typedef int (*TestFuncPtr)(int);	// 선언
TestFuncPtr testptr; 		        // 사용
==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

==================================================================================
    
==================================================================================

    
